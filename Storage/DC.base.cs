//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by StorageClassGenerator
//
//     Do not change code in this file, it will get lost when the file gets 
//     auto generated again. Write your code into DC.cs.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
using System;
using System.Threading;
using StorageLib;


namespace StorageLibBenchmark  {

  /// <summary>
  /// A part of DC is static, which gives easy access to all stored data (=context) through DC.Data. But most functionality is in the
  /// instantiatable part of DC. Since it is instantiatable, is possible to use different contexts over the lifetime of a program. This 
  /// is helpful for unit testing. Use DC.Init() to create a new context and dispose it with DisposeData() before creating a new one.
  /// </summary>
  public partial class DC: DataContextBase {

    #region static Part
    //      -----------

    /// <summary>
    /// Provides static root access to the data context
    /// </summary>
    public static DC Data {
      get { return data!; }
    }
    private static DC? data; //data is needed for Interlocked.Exchange(ref data, null) in DisposeData()


    /// <summary>
    /// Flushes all data to permanent storage location if permanent data storage is active. Compacts data storage
    /// by applying all updates and removing all instances marked as deleted.
    /// </summary>
    public static void DisposeData() {
      var dataLocal = Interlocked.Exchange(ref data, null);
      dataLocal?.Dispose();
    }
    #endregion


    #region Properties
    //      ----------

    /// <summary>
    /// Configuration parameters if data gets stored in .csv files
    /// </summary>
    public CsvConfig? CsvConfig { get; }

    /// <summary>
    /// Is all data initialised
    /// </summary>
    public bool IsInitialised { get; private set; }

    /// <summary>
    /// Directory of all SLibTestItems
    /// </summary>
    public IReadonlyDataStore<SLibTestItem> SLibTestItems => _SLibTestItems;
    internal DataStore<SLibTestItem> _SLibTestItems { get; private set; }
    #endregion


    #region Events
    //      ------

    #endregion


    #region Constructors
    //      ------------

    /// <summary>
    /// Creates a new DataContext. If csvConfig is null, the data is only stored in RAM and gets lost once the 
    /// program terminates. With csvConfig defined, existing data gets read at startup, changes get immediately
    /// written and Dispose() ensures by flushing that all data is permanently stored.
    /// </summary>
    public DC(CsvConfig? csvConfig): base(DataStoresCount: 1) {
      data = this;
      IsInitialised = false;

      string? backupResult = null;
      if (csvConfig!=null) {
        backupResult = Csv.Backup(csvConfig, DateTime.Now);
      }

      CsvConfig = csvConfig;
      onConstructing(backupResult);

      if (csvConfig==null) {
        _SLibTestItems = new DataStore<SLibTestItem>(
          this,
          0,
          SLibTestItem.SetKey,
          SLibTestItem.RollbackItemNew,
          SLibTestItem.RollbackItemStore,
          SLibTestItem.RollbackItemUpdate,
          SLibTestItem.RollbackItemRelease,
          areInstancesUpdatable: true,
          areInstancesReleasable: true);
        DataStores[0] = _SLibTestItems;
        onSLibTestItemsFilled();

      } else {
        IsPartiallyNew = false;
        _SLibTestItems = new DataStoreCSV<SLibTestItem>(
          this,
          0,
          csvConfig!,
          SLibTestItem.EstimatedLineLength,
          SLibTestItem.Headers,
          SLibTestItem.SetKey,
          SLibTestItem.Create,
          null,
          SLibTestItem.Update,
          SLibTestItem.Write,
          SLibTestItem.Disconnect,
          SLibTestItem.RollbackItemNew,
          SLibTestItem.RollbackItemStore,
          SLibTestItem.RollbackItemUpdate,
          SLibTestItem.RollbackItemRelease,
          areInstancesUpdatable: true,
          areInstancesReleasable: true);
        IsPartiallyNew |= _SLibTestItems.IsNew;
        IsNew &= _SLibTestItems.IsNew;
        DataStores[0] = _SLibTestItems;
        onSLibTestItemsFilled();

      }
      onConstructed();
      IsInitialised = true;
    }

    /// <summary>}
    /// Called at beginning of constructor
    /// </summary>}
    partial void onConstructing(string? backupResult);

    /// <summary>}
    /// Called at end of constructor
    /// </summary>}
    partial void onConstructed();

    /// <summary>}
    /// Called once the data for SLibTestItems is read.
    /// </summary>}
    partial void onSLibTestItemsFilled();
    #endregion


    #region Overrides
    //      ---------

    internal new void AddTransaction(TransactionItem transactionItem) {
      base.AddTransaction(transactionItem);
    }


    protected override void Dispose(bool disposing) {
      if (disposing) {
        onDispose();
        _SLibTestItems?.Dispose();
        _SLibTestItems = null!;
        data = null;
      }
      base.Dispose(disposing);
    }

    /// <summary>}
    /// Called before storageDirectories get disposed.
    /// </summary>}
    partial void onDispose();
    #endregion


    #region Methods
    //      -------

    #endregion

  }
}

